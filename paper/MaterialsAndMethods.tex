\section{Materials and Methods}

We first state our problem, then describe our data, showing all its characteristics. Then, we provide our hypothesis, define the setup, and perform the testing. Finally, we collect and perform data and regression analysis.

\subsection{Problem Statement}

As introduced in the first section of this paper, sorting is a fundamental concept and essential for solving other problems. The content of memory location can change unexpectedly, i.e., faults may happen at any time. Considering this, the main objective of this work is to design experiments to answer the following research question:

\begin{itemize}
    \item \textit{RQ1:} How are sorting algorithms affected by memory faults?
\end{itemize}

\subsection{Variables}

For this experimental study, we assume that the dependent and independent variables are as shown in Table \ref{table-variables} below:

\begin{table}[htbp]
    \caption{Dependent and independent variables.}
    \begin{center}
    \begin{tabular}{|c|c|}
    \hline
    \multicolumn{2}{|c|}{\textbf{Variables}}\\
    \hline
    \textbf{\textit{Dependent}} & \textbf{\textit{Independent}} \\
    \hline
    Largest subarray size & Probability of failure \\
    Percentage of largest subarray size related to the original array & Array size \\
    Unordered elements size & Sorting algorithm \\
    Percentage of unordered elements size related to the original array & \\
    \hline
    \end{tabular}
    \label{table-variables}
    \end{center}
\end{table}

\subsection{Hypothesis}

We define a set of hypothesis to test and draw some conclusions. They are:

\setcounter{hyp}{-1}
\begin{hyp}[Test hypothesis] \label{hyp:a}There is no difference in memory faults between tested algorithms.\end{hyp}
\begin{hyp} \label{hyp:b}There are differences in memory faults between tested algorithms. \end{hyp}
\begin{hyp} \label{hyp:c} An algorithm is better than others considering all dependent variables. \end{hyp}

\begin{hyp} \label{hyp:d} ... \end{hyp}

\subsection{Experimental Setup}

To conduct the proposed study we get a set of files with the basic setup and instructions, that was composed by:
\begin{itemize}
    \item A file that contains a sequence of integers that are the input data;
    \item Four files, one for each os those algorithms: quicksort, bubblesort, insertion sort, and mergesort, that are used to sorting the input data;
    \item An output file with the sorted data.
\end{itemize}

The input file looks like follow:

\begin{verbbox}[\mbox{}]
0.01 100 9 48 37 6 26 7 24 44 17 50 48 30 49 33 22 13 42 29 39 13 19 13 9 28 
34 1 33 27 14 45 48 40 11 17 6 50 9 44 20 16 37 45 23 14 38 29 10 49 44 46 35
45 15 2 22 1 46 40 8 48 23 23 32 35 3 15 8 36 17 24 27 48 28 5 28 50 44 4 25 
6 9 1 11 44 26 50 44 12 7 20 30 20 37 20 6 8 13 15 20 49
\end{verbbox}

\begin{figure}[hbtp]
    \centering
    \fbox{
    \theverbbox
    }
    \caption{Example of input file.}
    \label{input-file-example}
\end{figure}

The input data shown in the Figure \ref{input-file-example} is divided as follows:

\begin{itemize}
    \item \textit{Probability of Failure}: the first number of the sequence (\texttt{0.01}) is the probability of memory failure when sorting;
    \item \textit{Sequence size}: the second number (\texttt{100}) means the size of the integers sequence used by sorting;
    \item \textit{Sequence}: the rest of the numbers indicates the sequence itself.
\end{itemize}

We run 1000 times each algorithm with each file listed in Table \ref{table-input-data} below. We chose this number of executions to reduce possible noise in the generated data. Table \ref{table-input-data} shows 9 different input files with its sequence sizes and probabilities of failure. Plus, the number of executions and each sorting algorithm.

For example, Input A showed in that table with its characteristics was executed 1000 times for each algorithm -  bubblesort, quicksort, mergesort, and insertion sort - totalizing 4000 executions.

\begin{table}[H]
    \caption{Generated input data.}
    \begin{center}
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Input} & \textbf{Sequence Size} & \textbf{Probability of Failure} & \textbf{Executions} & \textbf{Algorithm} \\ 
    \hline
    \multirow{4}{*}{Input A} & \multirow{4}{*}{100} & \multirow{4}{*}{1\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \multirow{4}{*}{Input B} & \multirow{4}{*}{100} & \multirow{4}{*}{2\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \multirow{4}{*}{Input C} & \multirow{4}{*}{100} & \multirow{4}{*}{5\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \multirow{4}{*}{Input D} & \multirow{4}{*}{1000} & \multirow{4}{*}{1\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \multirow{4}{*}{Input E} & \multirow{4}{*}{1000} & \multirow{4}{*}{2\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \multirow{4}{*}{Input F} & \multirow{4}{*}{1000} & \multirow{4}{*}{5\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \multirow{4}{*}{Input G} & \multirow{4}{*}{10000} & \multirow{4}{*}{1\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \multirow{4}{*}{Input H} & \multirow{4}{*}{10000} & \multirow{4}{*}{2\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \multirow{4}{*}{Input I} & \multirow{4}{*}{10000} & \multirow{4}{*}{5\%} & \multirow{4}{*}{1000} & Bubblesort \\ 
    & & & & Quicksort \\
    & & & & Mergesort \\
    & & & & Insertion Sort \\
    \hline
    \end{tabular}
    \label{table-input-data}
    \end{center}
\end{table}

Each execution generates an output file. Then, we generate 4000 outputs for each combination of sequence size, and the probability of failure, totalizing 36000 files. Figure \ref{output-file-example} shows an output file.

\begin{verbbox}[\mbox{}]
[1]  9 48 37 6 26 7 24 44 17 50 48 30 49 33 22 13 42 29 39 13 19 13 9 28 34 1
33 27 14 45 48 40 11 17 6 50 9 44 20 16 37 45 23 14 38 29 10 49 44 46 35 45  
15 2 22 1 46 40 8 48 23 23 32 35 3 15 8 36 17 24 27 48 28 5 28 50 44 4 25 6 9
1 11 44 26 50 44 12 7 20 30 20 37 20 6 8 13 15 20 49
[2]  1 1 1 2 3 4 5 6 6 6 6 7 7 8 8 8 9 9 9 9 10 11 11 12 13 13 13 13 14 14 15 
15 15 16 17 17 17 19 20 20 20 20 22 22 23 23 23 24 24 25 26 26 27 27 28 28 28 
29 29 30 30 32 33 33 34 35 35 36 37 37 37 38 39 40 40 42 44 44 44 44 44 44 20 
45 45 45 46 46 48 48 48 48 48 49 49 50 49 50 50 50
[3]  1 1 1 2 3 4 5 6 6 6 6 7 7 8 8 8 9 9 9 9 10 11 11 12 13 13 13 13 14 14 15 
15 15 16 17 17 17 19 20 20 20 20 20 22 22 23 23 23 24 24 25 26 26 27 27 28 28 
28 29 29 30 30 32 33 33 34 35 35 36 37 37 37 38 39 40 40 42 44 44 44 44 44 44 
45 45 45 46 46 48 48 48 48 48 49 49 49 50 50 50 50
[4]  82
\end{verbbox}
    
\begin{figure}[H]
    \centering
    \fbox{
    \theverbbox
    }
    \caption{Example of output file.}
    \label{output-file-example}
\end{figure}

The output file gives four essential data, as enumerated below:
\begin{itemize}
    \item \textit{[1]}: the original sequence of integers contained in the input file;
    \item \textit{[2]}: the sequence processed by the sorting algorithm under the memory fault model;
    \item \textit{[3]}: the sequence sorted correctlty;
    \item \textit{[4]}: the size of the largest sorted subsequence in [2]. This number can be interpreted as the quality of sorting. As higher, most successful was the sorting operation.
\end{itemize}

\subsection{Development}

We develop Python scripts to generate input files and analyze our data. To be continued...

\subsection{Data Analysis}

\subsection{Conclusions}

