\section{Sorting Algorithms}

Sorting algorithms are widely used in many aspects of data processing, information searches, business finance, computer encryption, etc. This work uses four sorting algorithms: quicksort, mergesort, insertionsort, and bubblesort. In the following subsections, we'll give an overview of them.

\subsection{Quicksort}

Quicksort algorithm, created by Hoare \cite{Hoare1962}, is considered as one of the fastest and best sorting algorithms \cite{Wang2011}. The algorithm is based on the paradigm of divide and conquer.

This algorithm has a execution time of $\theta(n^2)$ in the worst case over \textit{n} numbers as input. Despite that execution time, quicksort is often the best option for sorting because of its remarkable average efficiency: $\theta(n lg n)$ \cite{Cormen2009}.

The basic steps of this algorithm are \cite{Wang2011}:
\begin{itemize}
    \item Pick an element, which is called a pivot, from the list waiting to be sorted;
    \item Perform partition operation to realize that all elements in the list with values smaller than the pivot came before the pivot. Otherwise, all elements in the list with values bigger than the pivot come after it (elements which are equal to pivot can go either way). After this partition, the pivot is in the final position of the list;
    \item Recursively sort the sub-list of smaller elements and the sub-list of the bigger elements.
\end{itemize}

\subsection{Mergesort}

Mergesort was invented by John Von Newman and is one of the most elegant algorithms to appear in the sorting literature. It is the first sorting algorithm to have $\theta(n lg n)$ execution time bound. It is important to observe that this algorithm spends a lot of time on data transfer operations. In fact, standard Mergesort incurs about 2n data move operations \cite{Abhyankar2011}.

Conceptually, Mergesort works as follows \cite{Abhyankar2011}:
\begin{itemize}
    \item Divide the unsorted array into two sub arrays of about half the size;
    \item Sort each sub array recursively;
    \item Merge the two sub arrays back into one array.
\end{itemize}

\subsection{Insertionsort}

This algorithm sorts the array by shifting the elements one at time. It is efficient in sorting a small number of elements. The overall execution time of this algorithm is $\theta(n^2)$ \cite{Cormen2009}. The basic sorting steps are:
\begin{itemize}
    \item If there are more than one element, pick the next element;
    \item Compare with all the elements in sorted sub-list;
    \item Shift all the elements in sorted sub-list that is greater than the value to be sorted;
    \item Insert the value;
    \item Repeat until list is sorted.
\end{itemize}

\subsection{Bubblesort}

The bubble sort is the oldest and simplest sorting method in use. It works by comparing each item in the list with the item next to it, and swapping them if required. The algorithm repeats this process until it makes a pass all the way through the list without swapping any items (in other words, all items are in the correct order) \cite{Mansotra2011}.

Table \ref{table1} below shows the time complexity comparison between the sorting algorithms presented. The \textit{n} is the number of input elements.

\begin{table}[htbp]
    \caption{Sorting algorithms complexity time comparison \cite{Prajapati2017}}
    \begin{center}
    \begin{tabular}{|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{Algorithm}}&\multicolumn{3}{|c|}{\textbf{Time Complexity}} \\
    \cline{2-4} 
    & \textbf{\textit{Best Case}} & \textbf{\textit{Average Case}}& \textbf{\textit{Worst Case}} \\
    \hline
    Bubblesort & $O(n^2)$ & $O(n^2)$ & $O(n^2)$ \\
    Insertionsort & $O(n)$ & $O(n^2)$ & $O(n^2)$ \\
    Quicksort & $O(nlgn)$ & $O(nlgn)$ & $O(n^2)$ \\
    Mergesort & $O(nlgn)$ & $O(nlgn)$ & $O(nlgn)$ \\
    \hline
    \end{tabular}
    \label{table1}
    \end{center}
\end{table}